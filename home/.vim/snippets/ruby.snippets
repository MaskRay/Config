# #!/usr/bin/ruby
snippet #!
	#!/usr/bin/ruby

# New Block
snippet =b
	=begin rdoc
		${1}
	=end

snippet req
	require "${1}"${2}
snippet case
	case ${1:object}
	when ${2:condition}
		${3}
	end
snippet when
	when ${1:condition}
		${2}
snippet def
	def ${1:method_name}
		${2}
	end
snippet if
	if ${1:condition}
		${2}
	end
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	end
snippet unless
	unless ${1:condition}
		${2}
	end
snippet while
	while ${1:condition}
		${2}
	end
snippet until
	until ${1:condition}
		${2}
	end
snippet cla class .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
snippet cla class .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		def initialize(${2:args})
			${3}
		end
	end
snippet mod module .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
# include Comparable
snippet Comp
	include Comparable

	def <=>(other)
		${1}
	end
# extend Forwardable
snippet Forw
	extend Forwardable
# def self
snippet defs
	def self.${1:class_method_name}
		${2}
	end
# def method_missing
snippet defmm
	def method_missing(meth, *args, &blk)
		${1}
	end
snippet defd
	def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}
snippet defds
	def_delegators :${1:@del_obj}, :${2:del_methods}
snippet am
	alias_method :${1:new_name}, :${2:old_name}
snippet app
	if __FILE__ == $PROGRAM_NAME
		${1}
	end
# usage_if()
snippet usai
	if ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end
# usage_unless()
snippet usau
	unless ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end
snippet array
	Array.new(${1:10}) {|${2:i}| ${3} }
snippet hash
	Hash.new {|${1:hash}, ${2:key}| $1[$2] = ${3} }
snippet file File.foreach() {|line| .. }
	File.foreach(${1:"path/to/file"}) {|${2:line}| ${3} }
snippet file File.read()
	File.read(${1:"path/to/file"})${2}
snippet Dir Dir.global() {|file| .. }
	Dir.glob(${1:"dir/glob/*"}) {|${2:file}| ${3} }
snippet Dir Dir[".."]
	Dir[${1:"glob/**/*.rb"}]${2}
snippet dir
	Filename.dirname(__FILE__)
snippet deli
	delete_if {|${1:e}| ${2} }
snippet fil
	fill(${1:range}) {|${2:i}| ${3} }
# flatten_once()
snippet flao
	inject(Array.new) {|${1:arr}, ${2:a}| $1.push(*$2)}${3}
snippet zip
	zip(${1:enums}) {|${2:row}| ${3} }
# downto(0) {|n| .. }
snippet dow
	downto(${1:0}) {|${2:n}| ${3} }
snippet ste
	step(${1:2}) {|${2:n}| ${3} }
snippet tim
	times {|${1:n}| ${2} }
snippet upt
	upto(${1:1.0/0.0}) {|${2:n}| ${3} }
snippet loo
	loop { ${1} }
snippet ea
	each {|${1:e}| ${2} }
snippet eab
	each_byte {|${1:byte}| ${2} }
snippet eac- each_char {|chr| .. }
	each_char {|${1:chr}| ${2} }
snippet eac- each_cons(..) {|group| .. }
	each_cons(${1:2}) {|${2:group}| ${3} }
snippet eai
	each_index {|${1:i}| ${2} }
snippet eak
	each_key {|${1:key}| ${2} }
snippet eal
	each_line {|${1:line}| ${2} }
snippet eap
	each_pair {|${1:name}, ${2:val}| ${3} }
snippet eas
	each_slice(${1:2}) {|${2:group}| ${3} }
snippet eav
	each_value {|${1:val}| ${2} }
snippet eawi
	each_with_index {|${1:e}, ${2:i}| ${3} }
snippet reve
	reverse_each {|${1:e}| ${2} }
snippet inj
	inject(${1:init}) {|${2:mem}, ${3:var}| ${4} }
snippet map
	map {|${1:e}| ${2} }
snippet mapwi
	enum_with_index.map {|${1:e}, ${2:i}| ${3} }
snippet sort
	sort {|a, b| ${1} }
snippet sortb
	sort_by {|${1:e}| ${2} }
snippet all
	all? {|${1:e}| ${2} }
snippet any
	any? {|${1:e}| ${2} }
snippet det
	detect {|${1:e}| ${2} }
snippet fin
	find {|${1:e}| ${2} }
snippet fina
	find_all {|${1:e}| ${2} }
snippet gre
	grep(${1:/pattern/}) {|${2:match}| ${3} }
snippet sub
	${1:g}sub(${2:/pattern/}) {|${3:match}| ${4} }
snippet sca
	scan(${1:/pattern/}) {|${2:match}| ${3} }
snippet max
	max {|a, b|, ${1} }
snippet min
	min {|a, b|, ${1} }
snippet par
	partition {|${1:e}|, ${2} }
snippet rej
	reject {|${1:e}|, ${2} }
snippet sel
	select {|${1:e}|, ${2} }
snippet lam
	lambda {|${1:args}| ${2} }
snippet do
	do |${1:variable}|
		${2}
	end
snippet opt
	opts.on( "-${1:o}", "--${2:long-option-name}", ${3:String},
	         "${4:Option description.}") do |${5:opt}|
		${6}
	end
snippet as
	assert(${1:test}, "${2:Failure message.}")${3}
snippet ase
	assert_equal(${1:expected}, ${2:actual})${3}
snippet asne
	assert_not_equal(${1:unexpected}, ${2:actual})${3}
snippet asid
	assert_in_delta(${1:expected_float}, ${2:actual_float}, ${3:2 ** -20})${4}
snippet asio
	assert_instance_of(${1:ExpectedClass}, ${2:actual_instance})${3}
snippet asko
	assert_kind_of(${1:ExpectedKind}, ${2:actual_instance})${3}
snippet asn
	assert_nil(${1:instance})${2}
snippet asnn
	assert_not_nil(${1:instance})${2}
snippet asm
	assert_match(/${1:expected_pattern}/, ${2:actual_string})${3}
snippet asnm
	assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})${3}
snippet aso
	assert_operator(${1:left}, :${2:operator}, ${3:right})${4}
snippet asr
	assert_raise(${1:Exception}) { ${2} }
snippet asnr
	assert_nothing_raised(${1:Exception}) { ${2} }
snippet asrt
	assert_respond_to(${1:object}, :${2:method})${3}
snippet ass assert_same(..)
	assert_same(${1:expected}, ${2:actual})${3}
snippet ass assert_send(..)
	assert_send([${1:object}, :${2:message}, ${3:args}])${4}
snippet asns
	assert_not_same(${1:unexpected}, ${2:actual})${3}
snippet ast
	assert_throws(:${1:expected}) { ${2} }
snippet asnt
	assert_nothing_thrown { ${1} }
snippet fl
	flunk("${1:Failure message.}")${2}
# Benchmark.bmbm do .. end
snippet bm-
	TESTS = ${1:10_000}
	Benchmark.bmbm do |results|
		${2}
	end
snippet rep
	results.report("${1:name}:") { TESTS.times { ${2} }}
# deep_copy(..)
snippet deec
	Marshal.load(Marshal.dump(${1:obj_to_copy}))${2}
snippet Pn-
	PStore.new(${1:"file_name.pstore"})${2}
snippet tra
	transaction(${1:true}) { ${2} }
# xmlread(..)
snippet xml-
	REXML::Document.new(File.read(${1:"path/to/file"}))${2}
# xpath(..) { .. }
snippet xpa
	elements.each(${1:"//Xpath"}) do |${2:node}|
		${3}
	end
# class_from_name()
snippet clafn
	split("::").inject(Object) {|par, const| par.const_get(const) }
# singleton_class()
snippet sinc
	class << self; self end
snippet nam
	namespace :${1:`Filename()`} do
		${2}
	end
snippet tas
	desc "${1:Task description\}"
	task :${2:task_name => [:dependent, :tasks]} do
		${3}
	end
snippet fopen
	File.open(${1:filename}, '${2:rwab}') {|${3:file}| ${4} }
	${5}
